import json
from datetime import datetime, date, timedelta
import os

ARQUIVO = "reservas.json"

# Capacidade por categoria (editable)
CAPACIDADES = {
    "Standard": 10,
    "Premium": 5,
    "Luxo": 2
}

# Lista global de reservas
reservas = []

# -------------------------
# Helpers de data e arquivo
# -------------------------
def parse_data(entrada_str):
    """
    Converte string para datetime.date.
    Formato aceito: DD/MM/AAAA
    """
    try:
        return datetime.strptime(entrada_str.strip(), "%d/%m/%Y").date()
    except ValueError:
        raise ValueError("Formato de data inválido. Use DD/MM/AAAA.")

def date_to_str(d: date):
    return d.isoformat()  # YYYY-MM-DD (fácil para JSON)

def str_to_date(s: str):
    return datetime.fromisoformat(s).date()

def salvar_reservas():
    """
    Salva a lista global reservas em JSON convertendo datas para strings.
    """
    serializavel = []
    for r in reservas:
        r_copy = r.copy()
        r_copy["checkin"] = date_to_str(r["checkin"])
        r_copy["checkout"] = date_to_str(r["checkout"])
        serializavel.append(r_copy)
    with open(ARQUIVO, "w", encoding="utf-8") as f:
        json.dump(serializavel, f, ensure_ascii=False, indent=2)
    print("Dados salvos em", ARQUIVO)

def carregar_reservas():
    """
    Carrega reservas do arquivo JSON convertendo strings em date.
    """
    global reservas
    if not os.path.exists(ARQUIVO):
        reservas = []
        return
    with open(ARQUIVO, "r", encoding="utf-8") as f:
        dados = json.load(f)
    carregadas = []
    for r in dados:
        try:
            carregadas.append({
                "id": r["id"],
                "responsavel": r["responsavel"],
                "checkin": str_to_date(r["checkin"]),
                "checkout": str_to_date(r["checkout"]),
                "tipo_quarto": r["tipo_quarto"],
                "quantidade_quartos": int(r["quantidade_quartos"]),
                "valor_total": float(r.get("valor_total", 0.0))
            })
        except Exception as e:
            print("Erro ao carregar uma reserva:", e)
    reservas = carregadas

# -------------------------
# Utilitários
# -------------------------
def gerar_proximo_id():
    if not reservas:
        return 1
    return max(r["id"] for r in reservas) + 1

def intervalo_sobrepoe(a_checkin, a_checkout, b_checkin, b_checkout):
    """
    Retorna True se os intervalos [a_checkin, a_checkout) e [b_checkin, b_checkout) se sobrepõem.
    Usamos half-open interval para facilitar.
    """
    return (a_checkin < b_checkout) and (b_checkin < a_checkout)

# -------------------------
# Disponibilidade e cadastro
# -------------------------
def verificar_disponibilidade(tipo_quarto, checkin, checkout, quartos_solicitados):
    """
    Verifica se há disponibilidade do tipo_quarto no período [checkin, checkout).
    Retorna True/False e a quantidade disponível máxima naquele período.
    """
    capacidade = CAPACIDADES.get(tipo_quarto)
    if capacidade is None:
        raise ValueError("Tipo de quarto desconhecido.")

    ocupado = 0
    for r in reservas:
        if r["tipo_quarto"] != tipo_quarto:
            continue
        if intervalo_sobrepoe(r["checkin"], r["checkout"], checkin, checkout):
            ocupado += r["quantidade_quartos"]
    disponivel = capacidade - ocupado
    return disponivel >= quartos_solicitados, max(0, disponivel)

def calcular_valor_total(tipo_quarto, checkin, checkout, quantidade_quartos):
    """
    Exemplo simples: cada categoria tem tarifa por noite.
    Essas tarifas são só um exemplo — você pode ajustar conforme desejar.
    """
    tarifas = {
        "Standard": 200.0,
        "Premium": 350.0,
        "Luxo": 600.0
    }
    tarifa = tarifas.get(tipo_quarto, 0.0)
    noites = (checkout - checkin).days
    if noites <= 0:
        raise ValueError("Checkout deve ser posterior ao checkin.")
    return tarifa * noites * quantidade_quartos

def cadastrar_reserva():
    print("\n=== Cadastro de Reserva ===")
    try:
        responsavel = input("Nome do responsável: ").strip()
        if not responsavel:
            print("Nome inválido.")
            return

        checkin = parse_data(input("Data de check-in (DD/MM/AAAA): "))
        checkout = parse_data(input("Data de check-out (DD/MM/AAAA): "))

        if checkout <= checkin:
            print("Checkout deve ser posterior ao check-in.")
            return

        print("Tipos disponíveis:", ", ".join(CAPACIDADES.keys()))
        tipo_quarto = input("Tipo de quarto (exactamente como acima): ").strip().title()
        if tipo_quarto not in CAPACIDADES:
            print("Tipo de quarto inválido.")
            return

        try:
            quantidade_quartos = int(input("Quantidade de quartos: "))
            if quantidade_quartos <= 0:
                print("Quantidade deve ser positiva.")
                return
        except ValueError:
            print("Quantidade inválida.")
            return

        disponivel, max_disp = verificar_disponibilidade(tipo_quarto, checkin, checkout, quantidade_quartos)
        if not disponivel:
            print(f"Não há {quantidade_quartos} quartos {tipo_quarto} disponíveis nesse período.")
            print(f"Max disponíveis: {max_disp}.")
            escolha = input("Deseja tentar outra quantidade (q) / outro tipo (t) / cancelar (c)? [q/t/c]: ").strip().lower()
            if escolha == "q":
                try:
                    nova_q = int(input("Nova quantidade de quartos: "))
                    if nova_q <= 0:
                        print("Quantidade inválida.")
                        return
                except ValueError:
                    print("Quantidade inválida.")
                    return
                disponivel, max_disp = verificar_disponibilidade(tipo_quarto, checkin, checkout, nova_q)
                if not disponivel:
                    print("Ainda não há disponibilidade.")
                    return
                quantidade_quartos = nova_q
            elif escolha == "t":
                novo_tipo = input("Novo tipo de quarto: ").strip().title()
                if novo_tipo not in CAPACIDADES:
                    print("Tipo inválido.")
                    return
                disponivel, max_disp = verificar_disponibilidade(novo_tipo, checkin, checkout, quantidade_quartos)
                if not disponivel:
                    print(f"Não há disponibilidade para {novo_tipo}. Máx: {max_disp}")
                    return
                tipo_quarto = novo_tipo
            else:
                print("Cancelando cadastro.")
                return

        valor_total = calcular_valor_total(tipo_quarto, checkin, checkout, quantidade_quartos)
        reserva = {
            "id": gerar_proximo_id(),
            "responsavel": responsavel,
            "checkin": checkin,
            "checkout": checkout,
            "tipo_quarto": tipo_quarto,
            "quantidade_quartos": quantidade_quartos,
            "valor_total": round(valor_total, 2)
        }
        reservas.append(reserva)
        salvar_reservas()
        print("Reserva cadastrada com sucesso! ID:", reserva["id"])
    except Exception as e:
        print("Erro no cadastro:", e)

# -------------------------
# Consultar, cancelar, listar
# -------------------------
def buscar_reservas_por_nome(nome):
    nome_lower = nome.strip().lower()
    encontrados = [r for r in reservas if nome_lower in r["responsavel"].lower()]
    return encontrados

def consultar_reservas():
    print("\n=== Consultar Reservas ===")
    nome = input("Nome do responsável para busca: ").strip()
    if not nome:
        print("Nome inválido.")
        return
    encontrados = buscar_reservas_por_nome(nome)
    if not encontrados:
        print("Nenhuma reserva encontrada.")
        return
    for r in encontrados:
        exibir_reserva(r)

def exibir_reserva(r):
    print("-" * 40)
    print(f"ID: {r['id']}")
    print(f"Responsável: {r['responsavel']}")
    print(f"Check-in: {r['checkin'].strftime('%d/%m/%Y')}")
    print(f"Check-out: {r['checkout'].strftime('%d/%m/%Y')}")
    noites = (r['checkout'] - r['checkin']).days
    print(f"Noites: {noites}")
    print(f"Tipo de quarto: {r['tipo_quarto']}")
    print(f"Quantidade de quartos: {r['quantidade_quartos']}")
    print(f"Valor total: R$ {r['valor_total']:.2f}")
    print("-" * 40)

def cancelar_reserva():
    print("\n=== Cancelar Reserva ===")
    nome = input("Nome do responsável da reserva a cancelar: ").strip()
    if not nome:
        print("Nome inválido.")
        return
    encontrados = buscar_reservas_por_nome(nome)
    if not encontrados:
        print("Nenhuma reserva encontrada para esse nome.")
        return
    # Mostrar apenas reservas futuras (checkin > hoje)
    hoje = date.today()
    futuras = [r for r in encontrados if r["checkin"] > hoje]
    if not futuras:
        print("Não há reservas futuras (a cancelar) para esse nome.")
        return
    print("Reservas futuras encontradas:")
    for r in futuras:
        exibir_reserva(r)
    try:
        id_str = input("Digite o ID da reserva que deseja cancelar (ou 't' para cancelar todas listadas): ").strip().lower()
        if id_str == "t":
            ids_para_remover = [r["id"] for r in futuras]
            confirmar = input(f"Confirma cancelamento de {len(ids_para_remover)} reservas? (s/n): ").strip().lower()
            if confirmar != "s":
                print("Operação cancelada.")
                return
            global reservas
            reservas = [r for r in reservas if r["id"] not in ids_para_remover]
            salvar_reservas()
            print(f"{len(ids_para_remover)} reservas canceladas.")
            return
        else:
            id_int = int(id_str)
            alvo = next((r for r in futuras if r["id"] == id_int), None)
            if not alvo:
                print("ID não encontrado entre as reservas futuras.")
                return
            confirmar = input(f"Confirma cancelamento da reserva ID {id_int}? (s/n): ").strip().lower()
            if confirmar != "s":
                print("Operação cancelada.")
                return
            reservas.remove(alvo)
            salvar_reservas()
            print("Reserva cancelada com sucesso.")
    except ValueError:
        print("Entrada inválida.")
    except Exception as e:
        print("Erro ao cancelar:", e)

def listar_reservas():
    print("\n=== Todas as Reservas ===")
    if not reservas:
        print("Nenhuma reserva cadastrada.")
        return
    # ordenar por checkin
    for r in sorted(reservas, key=lambda x: (x["checkin"], x["responsavel"])):
        exibir_reserva(r)

# -------------------------
# Estatísticas
# -------------------------
def calcular_estatisticas():
    print("\n=== Estatísticas Gerais ===")
    total_reservas = len(reservas)
    soma_valores = sum(r["valor_total"] for r in reservas)
    reserva_mais_cara = None
    reserva_mais_longa = None
    quartos_por_categoria = {k: 0 for k in CAPACIDADES.keys()}

    for r in reservas:
        if reserva_mais_cara is None or r["valor_total"] > reserva_mais_cara["valor_total"]:
            reserva_mais_cara = r
        dias = (r["checkout"] - r["checkin"]).days
        if reserva_mais_longa is None or dias > (reserva_mais_longa["checkout"] - reserva_mais_longa["checkin"]).days:
            reserva_mais_longa = r
        quartos_por_categoria[r["tipo_quarto"]] = quartos_por_categoria.get(r["tipo_quarto"], 0) + r["quantidade_quartos"]

    print("Total de reservas:", total_reservas)
    print(f"Soma total do valor das reservas: R$ {soma_valores:.2f}")
    if reserva_mais_cara:
        print("Reserva mais cara: ID", reserva_mais_cara["id"], "-", reserva_mais_cara["responsavel"], f"R$ {reserva_mais_cara['valor_total']:.2f}")
    else:
        print("Reserva mais cara: N/D")
    if reserva_mais_longa:
        dias = (reserva_mais_longa["checkout"] - reserva_mais_longa["checkin"]).days
        print("Reserva mais longa: ID", reserva_mais_longa["id"], "-", reserva_mais_longa["responsavel"], f"{dias} noites")
    else:
        print("Reserva mais longa: N/D")
    print("Quantidade total de quartos reservados por categoria:")
    for cat, qtd in quartos_por_categoria.items():
        print(f"  {cat}: {qtd}")

# -------------------------
# Menu principal
# -------------------------
def menu():
    carregar_reservas()
    while True:
        print("\n" + "="*30)
        print("Sistema de Reservas - Menu Principal")
        print("1 - Cadastrar nova reserva")
        print("2 - Consultar reservas por nome")
        print("3 - Cancelar reserva")
        print("4 - Listar todas as reservas")
        print("5 - Estatísticas gerais")
        print("6 - Exibir capacidades atuais (config)")
        print("0 - Sair")
        escolha = input("Escolha uma opção: ").strip()
        if escolha == "1":
            cadastrar_reserva()
        elif escolha == "2":
            consultar_reservas()
        elif escolha == "3":
            cancelar_reserva()
        elif escolha == "4":
            listar_reservas()
        elif escolha == "5":
            calcular_estatisticas()
        elif escolha == "6":
            print("Capacidades por categoria:")
            for k, v in CAPACIDADES.items():
                print(f"  {k}: {v} quartos")
        elif escolha == "0":
            print("Saindo. Salvando dados...")
            salvar_reservas()
            break
        else:
            print("Opção inválida. Tente novamente.")

if __name__ == "__main__":
    menu()
